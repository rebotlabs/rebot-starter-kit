import { router, usePage } from "@inertiajs/react"
import { createContext, useCallback, useContext, useEffect, useState } from "react"

type TranslationMessages = Record<string, unknown>
type I18nContextType = {
  currentLocale: string
  fallbackLocale: string
  messages: Record<string, TranslationMessages>
  t: (key: string, params?: Record<string, string | number>) => string
  setLocale: (locale: string) => Promise<void>
}

type InertiaPageProps = {
  i18n?: {
    current: string
    default: string
    messages: TranslationMessages
  }
}

const I18nContext = createContext<I18nContextType | null>(null)

export function I18nProvider({
  children,
  initialLocale,
  fallbackLocale,
  initialMessages = {},
}: {
  children: React.ReactNode
  initialLocale: string
  fallbackLocale: string
  initialMessages?: Record<string, TranslationMessages>
}) {
  const [currentLocale, setCurrentLocale] = useState(initialLocale)
  const [messages, setMessages] = useState<Record<string, TranslationMessages>>({
    [initialLocale]: initialMessages[initialLocale] || {},
    [fallbackLocale]: initialMessages[fallbackLocale] || {},
  })

  const loadLocaleMessages = useCallback(
    async (locale: string): Promise<TranslationMessages> => {
      if (messages[locale] && Object.keys(messages[locale]).length > 0) {
        return messages[locale]
      }

      try {
        // Load translation files generated by the inertia-i18n plugin
        const response = await fetch(`/lang/php_${locale}.json`)
        if (!response.ok) {
          throw new Error(`Failed to load translations for ${locale}`)
        }
        const localeMessages = await response.json()
        setMessages((prev: Record<string, TranslationMessages>) => ({ ...prev, [locale]: localeMessages }))
        return localeMessages
      } catch (error) {
        console.error(`Error loading translations for ${locale}:`, error)
        // Return empty object as fallback
        const emptyMessages = {}
        setMessages((prev: Record<string, TranslationMessages>) => ({ ...prev, [locale]: emptyMessages }))
        return emptyMessages
      }
    },
    [messages],
  )

  const setLocale = useCallback(
    async (locale: string) => {
      if (locale === currentLocale) return

      await loadLocaleMessages(locale)
      setCurrentLocale(locale)
    },
    [currentLocale, loadLocaleMessages],
  )

  const t = (key: string, params: Record<string, string | number> = {}): string => {
    // Access flat keys directly (php_en.json has flat structure like "nav.overview": "Overview")
    let message = messages[currentLocale]?.[key] as string | undefined

    // Fallback to fallback locale if not found
    if (!message && currentLocale !== fallbackLocale) {
      message = messages[fallbackLocale]?.[key] as string | undefined
    }

    // Return key if still not found
    if (!message || typeof message !== "string") {
      return key
    }

    // Replace parameters in the message (support both :param and {param} formats)
    return Object.entries(params).reduce((acc, [paramKey, value]) => {
      const laravel = new RegExp(`:${paramKey}\\b`, "g") // Laravel format: :param
      const bracket = new RegExp(`{${paramKey}}`, "g") // Bracket format: {param}
      return acc.replace(laravel, String(value)).replace(bracket, String(value))
    }, message)
  }

  // Load initial locale messages if not provided
  useEffect(() => {
    const loadInitialMessages = async () => {
      // Only load if we don't have messages for the current locale
      if (!messages[currentLocale] || Object.keys(messages[currentLocale]).length === 0) {
        await loadLocaleMessages(currentLocale)
      }
      // Load fallback locale if different and not already loaded
      if (currentLocale !== fallbackLocale && (!messages[fallbackLocale] || Object.keys(messages[fallbackLocale]).length === 0)) {
        await loadLocaleMessages(fallbackLocale)
      }
    }
    loadInitialMessages()
  }, [currentLocale, fallbackLocale, loadLocaleMessages, messages])

  // Listen for Inertia navigation events to update locale
  useEffect(() => {
    const handleNavigate = (event: CustomEvent) => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const page = (event.detail as any)?.page
      const newLocale = page?.props?.i18n?.current
      const newMessages = page?.props?.i18n?.messages

      if (newLocale && newLocale !== currentLocale) {
        setCurrentLocale(newLocale)

        // If we have new messages from the server, use them
        if (newMessages) {
          setMessages((prev) => ({
            ...prev,
            [newLocale]: newMessages,
          }))
        }
      }
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    router.on("navigate", handleNavigate as any)
    // Note: Inertia.js router doesn't have an 'off' method, so we can't clean up
    // This is generally not a problem since the router is a singleton
  }, [currentLocale])

  const contextValue: I18nContextType = {
    currentLocale,
    fallbackLocale,
    messages,
    t,
    setLocale,
  }

  return <I18nContext.Provider value={contextValue}>{children}</I18nContext.Provider>
}

export function useI18n(): I18nContextType {
  const context = useContext(I18nContext)
  if (!context) {
    throw new Error("useI18n must be used within an I18nProvider")
  }
  return context
}

export function useTranslation() {
  const { t } = useI18n()
  return t
}

// Hook to get translations from Inertia props for SSR compatibility
export function useInertiaTranslations() {
  const page = usePage<InertiaPageProps>()
  return page.props.i18n
}
